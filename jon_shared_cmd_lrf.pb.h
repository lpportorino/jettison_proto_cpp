// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: jon_shared_cmd_lrf.proto
// Protobuf C++ Version: 5.29.2

#ifndef jon_5fshared_5fcmd_5flrf_2eproto_2epb_2eh
#define jon_5fshared_5fcmd_5flrf_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "jon_shared_data_types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_jon_5fshared_5fcmd_5flrf_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_jon_5fshared_5fcmd_5flrf_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_jon_5fshared_5fcmd_5flrf_2eproto;
namespace cmd {
namespace Lrf {
class DisableFogMode;
struct DisableFogModeDefaultTypeInternal;
extern DisableFogModeDefaultTypeInternal _DisableFogMode_default_instance_;
class EnableFogMode;
struct EnableFogModeDefaultTypeInternal;
extern EnableFogModeDefaultTypeInternal _EnableFogMode_default_instance_;
class GetMeteo;
struct GetMeteoDefaultTypeInternal;
extern GetMeteoDefaultTypeInternal _GetMeteo_default_instance_;
class Measure;
struct MeasureDefaultTypeInternal;
extern MeasureDefaultTypeInternal _Measure_default_instance_;
class NewSession;
struct NewSessionDefaultTypeInternal;
extern NewSessionDefaultTypeInternal _NewSession_default_instance_;
class RefineOff;
struct RefineOffDefaultTypeInternal;
extern RefineOffDefaultTypeInternal _RefineOff_default_instance_;
class RefineOn;
struct RefineOnDefaultTypeInternal;
extern RefineOnDefaultTypeInternal _RefineOn_default_instance_;
class Root;
struct RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class ScanOff;
struct ScanOffDefaultTypeInternal;
extern ScanOffDefaultTypeInternal _ScanOff_default_instance_;
class ScanOn;
struct ScanOnDefaultTypeInternal;
extern ScanOnDefaultTypeInternal _ScanOn_default_instance_;
class SetScanMode;
struct SetScanModeDefaultTypeInternal;
extern SetScanModeDefaultTypeInternal _SetScanMode_default_instance_;
class Start;
struct StartDefaultTypeInternal;
extern StartDefaultTypeInternal _Start_default_instance_;
class Stop;
struct StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
class TargetDesignatorOff;
struct TargetDesignatorOffDefaultTypeInternal;
extern TargetDesignatorOffDefaultTypeInternal _TargetDesignatorOff_default_instance_;
class TargetDesignatorOnModeA;
struct TargetDesignatorOnModeADefaultTypeInternal;
extern TargetDesignatorOnModeADefaultTypeInternal _TargetDesignatorOnModeA_default_instance_;
class TargetDesignatorOnModeB;
struct TargetDesignatorOnModeBDefaultTypeInternal;
extern TargetDesignatorOnModeBDefaultTypeInternal _TargetDesignatorOnModeB_default_instance_;
}  // namespace Lrf
}  // namespace cmd
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cmd {
namespace Lrf {

// ===================================================================


// -------------------------------------------------------------------

class TargetDesignatorOnModeB final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.TargetDesignatorOnModeB) */ {
 public:
  inline TargetDesignatorOnModeB() : TargetDesignatorOnModeB(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TargetDesignatorOnModeB* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TargetDesignatorOnModeB));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TargetDesignatorOnModeB(
      ::google::protobuf::internal::ConstantInitialized);

  inline TargetDesignatorOnModeB(const TargetDesignatorOnModeB& from) : TargetDesignatorOnModeB(nullptr, from) {}
  inline TargetDesignatorOnModeB(TargetDesignatorOnModeB&& from) noexcept
      : TargetDesignatorOnModeB(nullptr, std::move(from)) {}
  inline TargetDesignatorOnModeB& operator=(const TargetDesignatorOnModeB& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetDesignatorOnModeB& operator=(TargetDesignatorOnModeB&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetDesignatorOnModeB& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetDesignatorOnModeB* internal_default_instance() {
    return reinterpret_cast<const TargetDesignatorOnModeB*>(
        &_TargetDesignatorOnModeB_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TargetDesignatorOnModeB& a, TargetDesignatorOnModeB& b) { a.Swap(&b); }
  inline void Swap(TargetDesignatorOnModeB* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetDesignatorOnModeB* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetDesignatorOnModeB* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<TargetDesignatorOnModeB>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TargetDesignatorOnModeB& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TargetDesignatorOnModeB& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.TargetDesignatorOnModeB"; }

 protected:
  explicit TargetDesignatorOnModeB(::google::protobuf::Arena* arena);
  TargetDesignatorOnModeB(::google::protobuf::Arena* arena, const TargetDesignatorOnModeB& from);
  TargetDesignatorOnModeB(::google::protobuf::Arena* arena, TargetDesignatorOnModeB&& from) noexcept
      : TargetDesignatorOnModeB(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.TargetDesignatorOnModeB)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TargetDesignatorOnModeB& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class TargetDesignatorOnModeA final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.TargetDesignatorOnModeA) */ {
 public:
  inline TargetDesignatorOnModeA() : TargetDesignatorOnModeA(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TargetDesignatorOnModeA* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TargetDesignatorOnModeA));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TargetDesignatorOnModeA(
      ::google::protobuf::internal::ConstantInitialized);

  inline TargetDesignatorOnModeA(const TargetDesignatorOnModeA& from) : TargetDesignatorOnModeA(nullptr, from) {}
  inline TargetDesignatorOnModeA(TargetDesignatorOnModeA&& from) noexcept
      : TargetDesignatorOnModeA(nullptr, std::move(from)) {}
  inline TargetDesignatorOnModeA& operator=(const TargetDesignatorOnModeA& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetDesignatorOnModeA& operator=(TargetDesignatorOnModeA&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetDesignatorOnModeA& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetDesignatorOnModeA* internal_default_instance() {
    return reinterpret_cast<const TargetDesignatorOnModeA*>(
        &_TargetDesignatorOnModeA_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(TargetDesignatorOnModeA& a, TargetDesignatorOnModeA& b) { a.Swap(&b); }
  inline void Swap(TargetDesignatorOnModeA* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetDesignatorOnModeA* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetDesignatorOnModeA* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<TargetDesignatorOnModeA>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TargetDesignatorOnModeA& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TargetDesignatorOnModeA& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.TargetDesignatorOnModeA"; }

 protected:
  explicit TargetDesignatorOnModeA(::google::protobuf::Arena* arena);
  TargetDesignatorOnModeA(::google::protobuf::Arena* arena, const TargetDesignatorOnModeA& from);
  TargetDesignatorOnModeA(::google::protobuf::Arena* arena, TargetDesignatorOnModeA&& from) noexcept
      : TargetDesignatorOnModeA(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.TargetDesignatorOnModeA)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TargetDesignatorOnModeA& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class TargetDesignatorOff final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.TargetDesignatorOff) */ {
 public:
  inline TargetDesignatorOff() : TargetDesignatorOff(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TargetDesignatorOff* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TargetDesignatorOff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TargetDesignatorOff(
      ::google::protobuf::internal::ConstantInitialized);

  inline TargetDesignatorOff(const TargetDesignatorOff& from) : TargetDesignatorOff(nullptr, from) {}
  inline TargetDesignatorOff(TargetDesignatorOff&& from) noexcept
      : TargetDesignatorOff(nullptr, std::move(from)) {}
  inline TargetDesignatorOff& operator=(const TargetDesignatorOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetDesignatorOff& operator=(TargetDesignatorOff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetDesignatorOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetDesignatorOff* internal_default_instance() {
    return reinterpret_cast<const TargetDesignatorOff*>(
        &_TargetDesignatorOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TargetDesignatorOff& a, TargetDesignatorOff& b) { a.Swap(&b); }
  inline void Swap(TargetDesignatorOff* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetDesignatorOff* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetDesignatorOff* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<TargetDesignatorOff>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TargetDesignatorOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TargetDesignatorOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.TargetDesignatorOff"; }

 protected:
  explicit TargetDesignatorOff(::google::protobuf::Arena* arena);
  TargetDesignatorOff(::google::protobuf::Arena* arena, const TargetDesignatorOff& from);
  TargetDesignatorOff(::google::protobuf::Arena* arena, TargetDesignatorOff&& from) noexcept
      : TargetDesignatorOff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.TargetDesignatorOff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TargetDesignatorOff& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class Stop final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.Stop) */ {
 public:
  inline Stop() : Stop(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Stop* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Stop));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Stop(
      ::google::protobuf::internal::ConstantInitialized);

  inline Stop(const Stop& from) : Stop(nullptr, from) {}
  inline Stop(Stop&& from) noexcept
      : Stop(nullptr, std::move(from)) {}
  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stop& operator=(Stop&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stop* internal_default_instance() {
    return reinterpret_cast<const Stop*>(
        &_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Stop& a, Stop& b) { a.Swap(&b); }
  inline void Swap(Stop* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stop* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Stop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Stop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Stop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.Stop"; }

 protected:
  explicit Stop(::google::protobuf::Arena* arena);
  Stop(::google::protobuf::Arena* arena, const Stop& from);
  Stop(::google::protobuf::Arena* arena, Stop&& from) noexcept
      : Stop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.Stop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Stop& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class Start final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.Start) */ {
 public:
  inline Start() : Start(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Start* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Start));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Start(
      ::google::protobuf::internal::ConstantInitialized);

  inline Start(const Start& from) : Start(nullptr, from) {}
  inline Start(Start&& from) noexcept
      : Start(nullptr, std::move(from)) {}
  inline Start& operator=(const Start& from) {
    CopyFrom(from);
    return *this;
  }
  inline Start& operator=(Start&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Start& default_instance() {
    return *internal_default_instance();
  }
  static inline const Start* internal_default_instance() {
    return reinterpret_cast<const Start*>(
        &_Start_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Start& a, Start& b) { a.Swap(&b); }
  inline void Swap(Start* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Start* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Start* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Start>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Start& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Start& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.Start"; }

 protected:
  explicit Start(::google::protobuf::Arena* arena);
  Start(::google::protobuf::Arena* arena, const Start& from);
  Start(::google::protobuf::Arena* arena, Start&& from) noexcept
      : Start(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.Start)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Start& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class SetScanMode final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cmd.Lrf.SetScanMode) */ {
 public:
  inline SetScanMode() : SetScanMode(nullptr) {}
  ~SetScanMode() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetScanMode* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetScanMode));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetScanMode(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetScanMode(const SetScanMode& from) : SetScanMode(nullptr, from) {}
  inline SetScanMode(SetScanMode&& from) noexcept
      : SetScanMode(nullptr, std::move(from)) {}
  inline SetScanMode& operator=(const SetScanMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetScanMode& operator=(SetScanMode&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetScanMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetScanMode* internal_default_instance() {
    return reinterpret_cast<const SetScanMode*>(
        &_SetScanMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SetScanMode& a, SetScanMode& b) { a.Swap(&b); }
  inline void Swap(SetScanMode* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetScanMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetScanMode* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetScanMode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetScanMode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetScanMode& from) { SetScanMode::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetScanMode* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.SetScanMode"; }

 protected:
  explicit SetScanMode(::google::protobuf::Arena* arena);
  SetScanMode(::google::protobuf::Arena* arena, const SetScanMode& from);
  SetScanMode(::google::protobuf::Arena* arena, SetScanMode&& from) noexcept
      : SetScanMode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModeFieldNumber = 1,
  };
  // .ser.JonGuiDataLrfScanModes mode = 1;
  void clear_mode() ;
  ::ser::JonGuiDataLrfScanModes mode() const;
  void set_mode(::ser::JonGuiDataLrfScanModes value);

  private:
  ::ser::JonGuiDataLrfScanModes _internal_mode() const;
  void _internal_set_mode(::ser::JonGuiDataLrfScanModes value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.Lrf.SetScanMode)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetScanMode& from_msg);
    int mode_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class ScanOn final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.ScanOn) */ {
 public:
  inline ScanOn() : ScanOn(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScanOn* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScanOn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScanOn(
      ::google::protobuf::internal::ConstantInitialized);

  inline ScanOn(const ScanOn& from) : ScanOn(nullptr, from) {}
  inline ScanOn(ScanOn&& from) noexcept
      : ScanOn(nullptr, std::move(from)) {}
  inline ScanOn& operator=(const ScanOn& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanOn& operator=(ScanOn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanOn& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanOn* internal_default_instance() {
    return reinterpret_cast<const ScanOn*>(
        &_ScanOn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ScanOn& a, ScanOn& b) { a.Swap(&b); }
  inline void Swap(ScanOn* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanOn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanOn* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ScanOn>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ScanOn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ScanOn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.ScanOn"; }

 protected:
  explicit ScanOn(::google::protobuf::Arena* arena);
  ScanOn(::google::protobuf::Arena* arena, const ScanOn& from);
  ScanOn(::google::protobuf::Arena* arena, ScanOn&& from) noexcept
      : ScanOn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.ScanOn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ScanOn& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class ScanOff final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.ScanOff) */ {
 public:
  inline ScanOff() : ScanOff(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScanOff* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScanOff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScanOff(
      ::google::protobuf::internal::ConstantInitialized);

  inline ScanOff(const ScanOff& from) : ScanOff(nullptr, from) {}
  inline ScanOff(ScanOff&& from) noexcept
      : ScanOff(nullptr, std::move(from)) {}
  inline ScanOff& operator=(const ScanOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanOff& operator=(ScanOff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanOff* internal_default_instance() {
    return reinterpret_cast<const ScanOff*>(
        &_ScanOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ScanOff& a, ScanOff& b) { a.Swap(&b); }
  inline void Swap(ScanOff* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanOff* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanOff* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ScanOff>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ScanOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ScanOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.ScanOff"; }

 protected:
  explicit ScanOff(::google::protobuf::Arena* arena);
  ScanOff(::google::protobuf::Arena* arena, const ScanOff& from);
  ScanOff(::google::protobuf::Arena* arena, ScanOff&& from) noexcept
      : ScanOff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.ScanOff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ScanOff& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class RefineOn final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.RefineOn) */ {
 public:
  inline RefineOn() : RefineOn(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RefineOn* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RefineOn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RefineOn(
      ::google::protobuf::internal::ConstantInitialized);

  inline RefineOn(const RefineOn& from) : RefineOn(nullptr, from) {}
  inline RefineOn(RefineOn&& from) noexcept
      : RefineOn(nullptr, std::move(from)) {}
  inline RefineOn& operator=(const RefineOn& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefineOn& operator=(RefineOn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefineOn& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefineOn* internal_default_instance() {
    return reinterpret_cast<const RefineOn*>(
        &_RefineOn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RefineOn& a, RefineOn& b) { a.Swap(&b); }
  inline void Swap(RefineOn* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefineOn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefineOn* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<RefineOn>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefineOn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefineOn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.RefineOn"; }

 protected:
  explicit RefineOn(::google::protobuf::Arena* arena);
  RefineOn(::google::protobuf::Arena* arena, const RefineOn& from);
  RefineOn(::google::protobuf::Arena* arena, RefineOn&& from) noexcept
      : RefineOn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.RefineOn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RefineOn& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class RefineOff final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.RefineOff) */ {
 public:
  inline RefineOff() : RefineOff(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RefineOff* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RefineOff));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RefineOff(
      ::google::protobuf::internal::ConstantInitialized);

  inline RefineOff(const RefineOff& from) : RefineOff(nullptr, from) {}
  inline RefineOff(RefineOff&& from) noexcept
      : RefineOff(nullptr, std::move(from)) {}
  inline RefineOff& operator=(const RefineOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefineOff& operator=(RefineOff&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefineOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefineOff* internal_default_instance() {
    return reinterpret_cast<const RefineOff*>(
        &_RefineOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RefineOff& a, RefineOff& b) { a.Swap(&b); }
  inline void Swap(RefineOff* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefineOff* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefineOff* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<RefineOff>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefineOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefineOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.RefineOff"; }

 protected:
  explicit RefineOff(::google::protobuf::Arena* arena);
  RefineOff(::google::protobuf::Arena* arena, const RefineOff& from);
  RefineOff(::google::protobuf::Arena* arena, RefineOff&& from) noexcept
      : RefineOff(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.RefineOff)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RefineOff& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class NewSession final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.NewSession) */ {
 public:
  inline NewSession() : NewSession(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NewSession* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NewSession));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NewSession(
      ::google::protobuf::internal::ConstantInitialized);

  inline NewSession(const NewSession& from) : NewSession(nullptr, from) {}
  inline NewSession(NewSession&& from) noexcept
      : NewSession(nullptr, std::move(from)) {}
  inline NewSession& operator=(const NewSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewSession& operator=(NewSession&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewSession* internal_default_instance() {
    return reinterpret_cast<const NewSession*>(
        &_NewSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(NewSession& a, NewSession& b) { a.Swap(&b); }
  inline void Swap(NewSession* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewSession* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewSession* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<NewSession>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NewSession& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NewSession& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.NewSession"; }

 protected:
  explicit NewSession(::google::protobuf::Arena* arena);
  NewSession(::google::protobuf::Arena* arena, const NewSession& from);
  NewSession(::google::protobuf::Arena* arena, NewSession&& from) noexcept
      : NewSession(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.NewSession)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NewSession& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class Measure final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.Measure) */ {
 public:
  inline Measure() : Measure(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Measure* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Measure));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Measure(
      ::google::protobuf::internal::ConstantInitialized);

  inline Measure(const Measure& from) : Measure(nullptr, from) {}
  inline Measure(Measure&& from) noexcept
      : Measure(nullptr, std::move(from)) {}
  inline Measure& operator=(const Measure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Measure& operator=(Measure&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Measure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Measure* internal_default_instance() {
    return reinterpret_cast<const Measure*>(
        &_Measure_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Measure& a, Measure& b) { a.Swap(&b); }
  inline void Swap(Measure* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Measure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Measure* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Measure>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Measure& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Measure& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.Measure"; }

 protected:
  explicit Measure(::google::protobuf::Arena* arena);
  Measure(::google::protobuf::Arena* arena, const Measure& from);
  Measure(::google::protobuf::Arena* arena, Measure&& from) noexcept
      : Measure(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.Measure)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Measure& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class GetMeteo final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.GetMeteo) */ {
 public:
  inline GetMeteo() : GetMeteo(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetMeteo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetMeteo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetMeteo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetMeteo(const GetMeteo& from) : GetMeteo(nullptr, from) {}
  inline GetMeteo(GetMeteo&& from) noexcept
      : GetMeteo(nullptr, std::move(from)) {}
  inline GetMeteo& operator=(const GetMeteo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMeteo& operator=(GetMeteo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMeteo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMeteo* internal_default_instance() {
    return reinterpret_cast<const GetMeteo*>(
        &_GetMeteo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GetMeteo& a, GetMeteo& b) { a.Swap(&b); }
  inline void Swap(GetMeteo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMeteo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMeteo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetMeteo>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetMeteo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetMeteo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.GetMeteo"; }

 protected:
  explicit GetMeteo(::google::protobuf::Arena* arena);
  GetMeteo(::google::protobuf::Arena* arena, const GetMeteo& from);
  GetMeteo(::google::protobuf::Arena* arena, GetMeteo&& from) noexcept
      : GetMeteo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.GetMeteo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetMeteo& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class EnableFogMode final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.EnableFogMode) */ {
 public:
  inline EnableFogMode() : EnableFogMode(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EnableFogMode* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EnableFogMode));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EnableFogMode(
      ::google::protobuf::internal::ConstantInitialized);

  inline EnableFogMode(const EnableFogMode& from) : EnableFogMode(nullptr, from) {}
  inline EnableFogMode(EnableFogMode&& from) noexcept
      : EnableFogMode(nullptr, std::move(from)) {}
  inline EnableFogMode& operator=(const EnableFogMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableFogMode& operator=(EnableFogMode&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableFogMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableFogMode* internal_default_instance() {
    return reinterpret_cast<const EnableFogMode*>(
        &_EnableFogMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(EnableFogMode& a, EnableFogMode& b) { a.Swap(&b); }
  inline void Swap(EnableFogMode* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableFogMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableFogMode* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<EnableFogMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EnableFogMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EnableFogMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.EnableFogMode"; }

 protected:
  explicit EnableFogMode(::google::protobuf::Arena* arena);
  EnableFogMode(::google::protobuf::Arena* arena, const EnableFogMode& from);
  EnableFogMode(::google::protobuf::Arena* arena, EnableFogMode&& from) noexcept
      : EnableFogMode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.EnableFogMode)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EnableFogMode& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class DisableFogMode final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cmd.Lrf.DisableFogMode) */ {
 public:
  inline DisableFogMode() : DisableFogMode(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DisableFogMode* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DisableFogMode));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DisableFogMode(
      ::google::protobuf::internal::ConstantInitialized);

  inline DisableFogMode(const DisableFogMode& from) : DisableFogMode(nullptr, from) {}
  inline DisableFogMode(DisableFogMode&& from) noexcept
      : DisableFogMode(nullptr, std::move(from)) {}
  inline DisableFogMode& operator=(const DisableFogMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableFogMode& operator=(DisableFogMode&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableFogMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableFogMode* internal_default_instance() {
    return reinterpret_cast<const DisableFogMode*>(
        &_DisableFogMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(DisableFogMode& a, DisableFogMode& b) { a.Swap(&b); }
  inline void Swap(DisableFogMode* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableFogMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableFogMode* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DisableFogMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DisableFogMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DisableFogMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.DisableFogMode"; }

 protected:
  explicit DisableFogMode(::google::protobuf::Arena* arena);
  DisableFogMode(::google::protobuf::Arena* arena, const DisableFogMode& from);
  DisableFogMode(::google::protobuf::Arena* arena, DisableFogMode&& from) noexcept
      : DisableFogMode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cmd.Lrf.DisableFogMode)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DisableFogMode& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};
// -------------------------------------------------------------------

class Root final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cmd.Lrf.Root) */ {
 public:
  inline Root() : Root(nullptr) {}
  ~Root() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Root* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Root));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Root(
      ::google::protobuf::internal::ConstantInitialized);

  inline Root(const Root& from) : Root(nullptr, from) {}
  inline Root(Root&& from) noexcept
      : Root(nullptr, std::move(from)) {}
  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  inline Root& operator=(Root&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Root& default_instance() {
    return *internal_default_instance();
  }
  enum CmdCase {
    kMeasure = 1,
    kScanOn = 2,
    kScanOff = 3,
    kStart = 4,
    kStop = 5,
    kTargetDesignatorOff = 6,
    kTargetDesignatorOnModeA = 7,
    kTargetDesignatorOnModeB = 8,
    kEnableFogMode = 9,
    kDisableFogMode = 10,
    kSetScanMode = 11,
    kNewSession = 12,
    kGetMeteo = 13,
    kRefineOn = 14,
    kRefineOff = 15,
    CMD_NOT_SET = 0,
  };
  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(
        &_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Root& a, Root& b) { a.Swap(&b); }
  inline void Swap(Root* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Root* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Root* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Root>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Root& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Root& from) { Root::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Root* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cmd.Lrf.Root"; }

 protected:
  explicit Root(::google::protobuf::Arena* arena);
  Root(::google::protobuf::Arena* arena, const Root& from);
  Root(::google::protobuf::Arena* arena, Root&& from) noexcept
      : Root(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMeasureFieldNumber = 1,
    kScanOnFieldNumber = 2,
    kScanOffFieldNumber = 3,
    kStartFieldNumber = 4,
    kStopFieldNumber = 5,
    kTargetDesignatorOffFieldNumber = 6,
    kTargetDesignatorOnModeAFieldNumber = 7,
    kTargetDesignatorOnModeBFieldNumber = 8,
    kEnableFogModeFieldNumber = 9,
    kDisableFogModeFieldNumber = 10,
    kSetScanModeFieldNumber = 11,
    kNewSessionFieldNumber = 12,
    kGetMeteoFieldNumber = 13,
    kRefineOnFieldNumber = 14,
    kRefineOffFieldNumber = 15,
  };
  // .cmd.Lrf.Measure measure = 1;
  bool has_measure() const;
  private:
  bool _internal_has_measure() const;

  public:
  void clear_measure() ;
  const ::cmd::Lrf::Measure& measure() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::Measure* release_measure();
  ::cmd::Lrf::Measure* mutable_measure();
  void set_allocated_measure(::cmd::Lrf::Measure* value);
  void unsafe_arena_set_allocated_measure(::cmd::Lrf::Measure* value);
  ::cmd::Lrf::Measure* unsafe_arena_release_measure();

  private:
  const ::cmd::Lrf::Measure& _internal_measure() const;
  ::cmd::Lrf::Measure* _internal_mutable_measure();

  public:
  // .cmd.Lrf.ScanOn scan_on = 2;
  bool has_scan_on() const;
  private:
  bool _internal_has_scan_on() const;

  public:
  void clear_scan_on() ;
  const ::cmd::Lrf::ScanOn& scan_on() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::ScanOn* release_scan_on();
  ::cmd::Lrf::ScanOn* mutable_scan_on();
  void set_allocated_scan_on(::cmd::Lrf::ScanOn* value);
  void unsafe_arena_set_allocated_scan_on(::cmd::Lrf::ScanOn* value);
  ::cmd::Lrf::ScanOn* unsafe_arena_release_scan_on();

  private:
  const ::cmd::Lrf::ScanOn& _internal_scan_on() const;
  ::cmd::Lrf::ScanOn* _internal_mutable_scan_on();

  public:
  // .cmd.Lrf.ScanOff scan_off = 3;
  bool has_scan_off() const;
  private:
  bool _internal_has_scan_off() const;

  public:
  void clear_scan_off() ;
  const ::cmd::Lrf::ScanOff& scan_off() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::ScanOff* release_scan_off();
  ::cmd::Lrf::ScanOff* mutable_scan_off();
  void set_allocated_scan_off(::cmd::Lrf::ScanOff* value);
  void unsafe_arena_set_allocated_scan_off(::cmd::Lrf::ScanOff* value);
  ::cmd::Lrf::ScanOff* unsafe_arena_release_scan_off();

  private:
  const ::cmd::Lrf::ScanOff& _internal_scan_off() const;
  ::cmd::Lrf::ScanOff* _internal_mutable_scan_off();

  public:
  // .cmd.Lrf.Start start = 4;
  bool has_start() const;
  private:
  bool _internal_has_start() const;

  public:
  void clear_start() ;
  const ::cmd::Lrf::Start& start() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::Start* release_start();
  ::cmd::Lrf::Start* mutable_start();
  void set_allocated_start(::cmd::Lrf::Start* value);
  void unsafe_arena_set_allocated_start(::cmd::Lrf::Start* value);
  ::cmd::Lrf::Start* unsafe_arena_release_start();

  private:
  const ::cmd::Lrf::Start& _internal_start() const;
  ::cmd::Lrf::Start* _internal_mutable_start();

  public:
  // .cmd.Lrf.Stop stop = 5;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;

  public:
  void clear_stop() ;
  const ::cmd::Lrf::Stop& stop() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::Stop* release_stop();
  ::cmd::Lrf::Stop* mutable_stop();
  void set_allocated_stop(::cmd::Lrf::Stop* value);
  void unsafe_arena_set_allocated_stop(::cmd::Lrf::Stop* value);
  ::cmd::Lrf::Stop* unsafe_arena_release_stop();

  private:
  const ::cmd::Lrf::Stop& _internal_stop() const;
  ::cmd::Lrf::Stop* _internal_mutable_stop();

  public:
  // .cmd.Lrf.TargetDesignatorOff target_designator_off = 6;
  bool has_target_designator_off() const;
  private:
  bool _internal_has_target_designator_off() const;

  public:
  void clear_target_designator_off() ;
  const ::cmd::Lrf::TargetDesignatorOff& target_designator_off() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::TargetDesignatorOff* release_target_designator_off();
  ::cmd::Lrf::TargetDesignatorOff* mutable_target_designator_off();
  void set_allocated_target_designator_off(::cmd::Lrf::TargetDesignatorOff* value);
  void unsafe_arena_set_allocated_target_designator_off(::cmd::Lrf::TargetDesignatorOff* value);
  ::cmd::Lrf::TargetDesignatorOff* unsafe_arena_release_target_designator_off();

  private:
  const ::cmd::Lrf::TargetDesignatorOff& _internal_target_designator_off() const;
  ::cmd::Lrf::TargetDesignatorOff* _internal_mutable_target_designator_off();

  public:
  // .cmd.Lrf.TargetDesignatorOnModeA target_designator_on_mode_a = 7;
  bool has_target_designator_on_mode_a() const;
  private:
  bool _internal_has_target_designator_on_mode_a() const;

  public:
  void clear_target_designator_on_mode_a() ;
  const ::cmd::Lrf::TargetDesignatorOnModeA& target_designator_on_mode_a() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::TargetDesignatorOnModeA* release_target_designator_on_mode_a();
  ::cmd::Lrf::TargetDesignatorOnModeA* mutable_target_designator_on_mode_a();
  void set_allocated_target_designator_on_mode_a(::cmd::Lrf::TargetDesignatorOnModeA* value);
  void unsafe_arena_set_allocated_target_designator_on_mode_a(::cmd::Lrf::TargetDesignatorOnModeA* value);
  ::cmd::Lrf::TargetDesignatorOnModeA* unsafe_arena_release_target_designator_on_mode_a();

  private:
  const ::cmd::Lrf::TargetDesignatorOnModeA& _internal_target_designator_on_mode_a() const;
  ::cmd::Lrf::TargetDesignatorOnModeA* _internal_mutable_target_designator_on_mode_a();

  public:
  // .cmd.Lrf.TargetDesignatorOnModeB target_designator_on_mode_b = 8;
  bool has_target_designator_on_mode_b() const;
  private:
  bool _internal_has_target_designator_on_mode_b() const;

  public:
  void clear_target_designator_on_mode_b() ;
  const ::cmd::Lrf::TargetDesignatorOnModeB& target_designator_on_mode_b() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::TargetDesignatorOnModeB* release_target_designator_on_mode_b();
  ::cmd::Lrf::TargetDesignatorOnModeB* mutable_target_designator_on_mode_b();
  void set_allocated_target_designator_on_mode_b(::cmd::Lrf::TargetDesignatorOnModeB* value);
  void unsafe_arena_set_allocated_target_designator_on_mode_b(::cmd::Lrf::TargetDesignatorOnModeB* value);
  ::cmd::Lrf::TargetDesignatorOnModeB* unsafe_arena_release_target_designator_on_mode_b();

  private:
  const ::cmd::Lrf::TargetDesignatorOnModeB& _internal_target_designator_on_mode_b() const;
  ::cmd::Lrf::TargetDesignatorOnModeB* _internal_mutable_target_designator_on_mode_b();

  public:
  // .cmd.Lrf.EnableFogMode enable_fog_mode = 9;
  bool has_enable_fog_mode() const;
  private:
  bool _internal_has_enable_fog_mode() const;

  public:
  void clear_enable_fog_mode() ;
  const ::cmd::Lrf::EnableFogMode& enable_fog_mode() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::EnableFogMode* release_enable_fog_mode();
  ::cmd::Lrf::EnableFogMode* mutable_enable_fog_mode();
  void set_allocated_enable_fog_mode(::cmd::Lrf::EnableFogMode* value);
  void unsafe_arena_set_allocated_enable_fog_mode(::cmd::Lrf::EnableFogMode* value);
  ::cmd::Lrf::EnableFogMode* unsafe_arena_release_enable_fog_mode();

  private:
  const ::cmd::Lrf::EnableFogMode& _internal_enable_fog_mode() const;
  ::cmd::Lrf::EnableFogMode* _internal_mutable_enable_fog_mode();

  public:
  // .cmd.Lrf.DisableFogMode disable_fog_mode = 10;
  bool has_disable_fog_mode() const;
  private:
  bool _internal_has_disable_fog_mode() const;

  public:
  void clear_disable_fog_mode() ;
  const ::cmd::Lrf::DisableFogMode& disable_fog_mode() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::DisableFogMode* release_disable_fog_mode();
  ::cmd::Lrf::DisableFogMode* mutable_disable_fog_mode();
  void set_allocated_disable_fog_mode(::cmd::Lrf::DisableFogMode* value);
  void unsafe_arena_set_allocated_disable_fog_mode(::cmd::Lrf::DisableFogMode* value);
  ::cmd::Lrf::DisableFogMode* unsafe_arena_release_disable_fog_mode();

  private:
  const ::cmd::Lrf::DisableFogMode& _internal_disable_fog_mode() const;
  ::cmd::Lrf::DisableFogMode* _internal_mutable_disable_fog_mode();

  public:
  // .cmd.Lrf.SetScanMode set_scan_mode = 11;
  bool has_set_scan_mode() const;
  private:
  bool _internal_has_set_scan_mode() const;

  public:
  void clear_set_scan_mode() ;
  const ::cmd::Lrf::SetScanMode& set_scan_mode() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::SetScanMode* release_set_scan_mode();
  ::cmd::Lrf::SetScanMode* mutable_set_scan_mode();
  void set_allocated_set_scan_mode(::cmd::Lrf::SetScanMode* value);
  void unsafe_arena_set_allocated_set_scan_mode(::cmd::Lrf::SetScanMode* value);
  ::cmd::Lrf::SetScanMode* unsafe_arena_release_set_scan_mode();

  private:
  const ::cmd::Lrf::SetScanMode& _internal_set_scan_mode() const;
  ::cmd::Lrf::SetScanMode* _internal_mutable_set_scan_mode();

  public:
  // .cmd.Lrf.NewSession new_session = 12;
  bool has_new_session() const;
  private:
  bool _internal_has_new_session() const;

  public:
  void clear_new_session() ;
  const ::cmd::Lrf::NewSession& new_session() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::NewSession* release_new_session();
  ::cmd::Lrf::NewSession* mutable_new_session();
  void set_allocated_new_session(::cmd::Lrf::NewSession* value);
  void unsafe_arena_set_allocated_new_session(::cmd::Lrf::NewSession* value);
  ::cmd::Lrf::NewSession* unsafe_arena_release_new_session();

  private:
  const ::cmd::Lrf::NewSession& _internal_new_session() const;
  ::cmd::Lrf::NewSession* _internal_mutable_new_session();

  public:
  // .cmd.Lrf.GetMeteo get_meteo = 13;
  bool has_get_meteo() const;
  private:
  bool _internal_has_get_meteo() const;

  public:
  void clear_get_meteo() ;
  const ::cmd::Lrf::GetMeteo& get_meteo() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::GetMeteo* release_get_meteo();
  ::cmd::Lrf::GetMeteo* mutable_get_meteo();
  void set_allocated_get_meteo(::cmd::Lrf::GetMeteo* value);
  void unsafe_arena_set_allocated_get_meteo(::cmd::Lrf::GetMeteo* value);
  ::cmd::Lrf::GetMeteo* unsafe_arena_release_get_meteo();

  private:
  const ::cmd::Lrf::GetMeteo& _internal_get_meteo() const;
  ::cmd::Lrf::GetMeteo* _internal_mutable_get_meteo();

  public:
  // .cmd.Lrf.RefineOn refine_on = 14;
  bool has_refine_on() const;
  private:
  bool _internal_has_refine_on() const;

  public:
  void clear_refine_on() ;
  const ::cmd::Lrf::RefineOn& refine_on() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::RefineOn* release_refine_on();
  ::cmd::Lrf::RefineOn* mutable_refine_on();
  void set_allocated_refine_on(::cmd::Lrf::RefineOn* value);
  void unsafe_arena_set_allocated_refine_on(::cmd::Lrf::RefineOn* value);
  ::cmd::Lrf::RefineOn* unsafe_arena_release_refine_on();

  private:
  const ::cmd::Lrf::RefineOn& _internal_refine_on() const;
  ::cmd::Lrf::RefineOn* _internal_mutable_refine_on();

  public:
  // .cmd.Lrf.RefineOff refine_off = 15;
  bool has_refine_off() const;
  private:
  bool _internal_has_refine_off() const;

  public:
  void clear_refine_off() ;
  const ::cmd::Lrf::RefineOff& refine_off() const;
  PROTOBUF_NODISCARD ::cmd::Lrf::RefineOff* release_refine_off();
  ::cmd::Lrf::RefineOff* mutable_refine_off();
  void set_allocated_refine_off(::cmd::Lrf::RefineOff* value);
  void unsafe_arena_set_allocated_refine_off(::cmd::Lrf::RefineOff* value);
  ::cmd::Lrf::RefineOff* unsafe_arena_release_refine_off();

  private:
  const ::cmd::Lrf::RefineOff& _internal_refine_off() const;
  ::cmd::Lrf::RefineOff* _internal_mutable_refine_off();

  public:
  void clear_cmd();
  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:cmd.Lrf.Root)
 private:
  class _Internal;
  void set_has_measure();
  void set_has_scan_on();
  void set_has_scan_off();
  void set_has_start();
  void set_has_stop();
  void set_has_target_designator_off();
  void set_has_target_designator_on_mode_a();
  void set_has_target_designator_on_mode_b();
  void set_has_enable_fog_mode();
  void set_has_disable_fog_mode();
  void set_has_set_scan_mode();
  void set_has_new_session();
  void set_has_get_meteo();
  void set_has_refine_on();
  void set_has_refine_off();
  inline bool has_cmd() const;
  inline void clear_has_cmd();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 15, 15,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Root& from_msg);
    union CmdUnion {
      constexpr CmdUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cmd::Lrf::Measure* measure_;
      ::cmd::Lrf::ScanOn* scan_on_;
      ::cmd::Lrf::ScanOff* scan_off_;
      ::cmd::Lrf::Start* start_;
      ::cmd::Lrf::Stop* stop_;
      ::cmd::Lrf::TargetDesignatorOff* target_designator_off_;
      ::cmd::Lrf::TargetDesignatorOnModeA* target_designator_on_mode_a_;
      ::cmd::Lrf::TargetDesignatorOnModeB* target_designator_on_mode_b_;
      ::cmd::Lrf::EnableFogMode* enable_fog_mode_;
      ::cmd::Lrf::DisableFogMode* disable_fog_mode_;
      ::cmd::Lrf::SetScanMode* set_scan_mode_;
      ::cmd::Lrf::NewSession* new_session_;
      ::cmd::Lrf::GetMeteo* get_meteo_;
      ::cmd::Lrf::RefineOn* refine_on_;
      ::cmd::Lrf::RefineOff* refine_off_;
    } cmd_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5flrf_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Root

// .cmd.Lrf.Measure measure = 1;
inline bool Root::has_measure() const {
  return cmd_case() == kMeasure;
}
inline bool Root::_internal_has_measure() const {
  return cmd_case() == kMeasure;
}
inline void Root::set_has_measure() {
  _impl_._oneof_case_[0] = kMeasure;
}
inline void Root::clear_measure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kMeasure) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.measure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.measure_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::Measure* Root::release_measure() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.measure)
  if (cmd_case() == kMeasure) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.measure_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.measure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::Measure& Root::_internal_measure() const {
  return cmd_case() == kMeasure ? *_impl_.cmd_.measure_ : reinterpret_cast<::cmd::Lrf::Measure&>(::cmd::Lrf::_Measure_default_instance_);
}
inline const ::cmd::Lrf::Measure& Root::measure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.measure)
  return _internal_measure();
}
inline ::cmd::Lrf::Measure* Root::unsafe_arena_release_measure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.measure)
  if (cmd_case() == kMeasure) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.measure_;
    _impl_.cmd_.measure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_measure(::cmd::Lrf::Measure* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_measure();
    _impl_.cmd_.measure_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.measure)
}
inline ::cmd::Lrf::Measure* Root::_internal_mutable_measure() {
  if (cmd_case() != kMeasure) {
    clear_cmd();
    set_has_measure();
    _impl_.cmd_.measure_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::Measure>(GetArena());
  }
  return _impl_.cmd_.measure_;
}
inline ::cmd::Lrf::Measure* Root::mutable_measure() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::Measure* _msg = _internal_mutable_measure();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.measure)
  return _msg;
}

// .cmd.Lrf.ScanOn scan_on = 2;
inline bool Root::has_scan_on() const {
  return cmd_case() == kScanOn;
}
inline bool Root::_internal_has_scan_on() const {
  return cmd_case() == kScanOn;
}
inline void Root::set_has_scan_on() {
  _impl_._oneof_case_[0] = kScanOn;
}
inline void Root::clear_scan_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kScanOn) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.scan_on_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.scan_on_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::ScanOn* Root::release_scan_on() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.scan_on)
  if (cmd_case() == kScanOn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.scan_on_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.scan_on_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::ScanOn& Root::_internal_scan_on() const {
  return cmd_case() == kScanOn ? *_impl_.cmd_.scan_on_ : reinterpret_cast<::cmd::Lrf::ScanOn&>(::cmd::Lrf::_ScanOn_default_instance_);
}
inline const ::cmd::Lrf::ScanOn& Root::scan_on() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.scan_on)
  return _internal_scan_on();
}
inline ::cmd::Lrf::ScanOn* Root::unsafe_arena_release_scan_on() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.scan_on)
  if (cmd_case() == kScanOn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.scan_on_;
    _impl_.cmd_.scan_on_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_scan_on(::cmd::Lrf::ScanOn* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_scan_on();
    _impl_.cmd_.scan_on_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.scan_on)
}
inline ::cmd::Lrf::ScanOn* Root::_internal_mutable_scan_on() {
  if (cmd_case() != kScanOn) {
    clear_cmd();
    set_has_scan_on();
    _impl_.cmd_.scan_on_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::ScanOn>(GetArena());
  }
  return _impl_.cmd_.scan_on_;
}
inline ::cmd::Lrf::ScanOn* Root::mutable_scan_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::ScanOn* _msg = _internal_mutable_scan_on();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.scan_on)
  return _msg;
}

// .cmd.Lrf.ScanOff scan_off = 3;
inline bool Root::has_scan_off() const {
  return cmd_case() == kScanOff;
}
inline bool Root::_internal_has_scan_off() const {
  return cmd_case() == kScanOff;
}
inline void Root::set_has_scan_off() {
  _impl_._oneof_case_[0] = kScanOff;
}
inline void Root::clear_scan_off() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kScanOff) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.scan_off_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.scan_off_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::ScanOff* Root::release_scan_off() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.scan_off)
  if (cmd_case() == kScanOff) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.scan_off_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.scan_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::ScanOff& Root::_internal_scan_off() const {
  return cmd_case() == kScanOff ? *_impl_.cmd_.scan_off_ : reinterpret_cast<::cmd::Lrf::ScanOff&>(::cmd::Lrf::_ScanOff_default_instance_);
}
inline const ::cmd::Lrf::ScanOff& Root::scan_off() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.scan_off)
  return _internal_scan_off();
}
inline ::cmd::Lrf::ScanOff* Root::unsafe_arena_release_scan_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.scan_off)
  if (cmd_case() == kScanOff) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.scan_off_;
    _impl_.cmd_.scan_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_scan_off(::cmd::Lrf::ScanOff* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_scan_off();
    _impl_.cmd_.scan_off_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.scan_off)
}
inline ::cmd::Lrf::ScanOff* Root::_internal_mutable_scan_off() {
  if (cmd_case() != kScanOff) {
    clear_cmd();
    set_has_scan_off();
    _impl_.cmd_.scan_off_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::ScanOff>(GetArena());
  }
  return _impl_.cmd_.scan_off_;
}
inline ::cmd::Lrf::ScanOff* Root::mutable_scan_off() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::ScanOff* _msg = _internal_mutable_scan_off();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.scan_off)
  return _msg;
}

// .cmd.Lrf.Start start = 4;
inline bool Root::has_start() const {
  return cmd_case() == kStart;
}
inline bool Root::_internal_has_start() const {
  return cmd_case() == kStart;
}
inline void Root::set_has_start() {
  _impl_._oneof_case_[0] = kStart;
}
inline void Root::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kStart) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.start_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.start_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::Start* Root::release_start() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.start)
  if (cmd_case() == kStart) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.start_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::Start& Root::_internal_start() const {
  return cmd_case() == kStart ? *_impl_.cmd_.start_ : reinterpret_cast<::cmd::Lrf::Start&>(::cmd::Lrf::_Start_default_instance_);
}
inline const ::cmd::Lrf::Start& Root::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.start)
  return _internal_start();
}
inline ::cmd::Lrf::Start* Root::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.start)
  if (cmd_case() == kStart) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.start_;
    _impl_.cmd_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_start(::cmd::Lrf::Start* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_start();
    _impl_.cmd_.start_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.start)
}
inline ::cmd::Lrf::Start* Root::_internal_mutable_start() {
  if (cmd_case() != kStart) {
    clear_cmd();
    set_has_start();
    _impl_.cmd_.start_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::Start>(GetArena());
  }
  return _impl_.cmd_.start_;
}
inline ::cmd::Lrf::Start* Root::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::Start* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.start)
  return _msg;
}

// .cmd.Lrf.Stop stop = 5;
inline bool Root::has_stop() const {
  return cmd_case() == kStop;
}
inline bool Root::_internal_has_stop() const {
  return cmd_case() == kStop;
}
inline void Root::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void Root::clear_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kStop) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.stop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.stop_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::Stop* Root::release_stop() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.stop)
  if (cmd_case() == kStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::Stop& Root::_internal_stop() const {
  return cmd_case() == kStop ? *_impl_.cmd_.stop_ : reinterpret_cast<::cmd::Lrf::Stop&>(::cmd::Lrf::_Stop_default_instance_);
}
inline const ::cmd::Lrf::Stop& Root::stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.stop)
  return _internal_stop();
}
inline ::cmd::Lrf::Stop* Root::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.stop)
  if (cmd_case() == kStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.stop_;
    _impl_.cmd_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_stop(::cmd::Lrf::Stop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_stop();
    _impl_.cmd_.stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.stop)
}
inline ::cmd::Lrf::Stop* Root::_internal_mutable_stop() {
  if (cmd_case() != kStop) {
    clear_cmd();
    set_has_stop();
    _impl_.cmd_.stop_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::Stop>(GetArena());
  }
  return _impl_.cmd_.stop_;
}
inline ::cmd::Lrf::Stop* Root::mutable_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::Stop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.stop)
  return _msg;
}

// .cmd.Lrf.TargetDesignatorOff target_designator_off = 6;
inline bool Root::has_target_designator_off() const {
  return cmd_case() == kTargetDesignatorOff;
}
inline bool Root::_internal_has_target_designator_off() const {
  return cmd_case() == kTargetDesignatorOff;
}
inline void Root::set_has_target_designator_off() {
  _impl_._oneof_case_[0] = kTargetDesignatorOff;
}
inline void Root::clear_target_designator_off() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kTargetDesignatorOff) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.target_designator_off_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.target_designator_off_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::TargetDesignatorOff* Root::release_target_designator_off() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.target_designator_off)
  if (cmd_case() == kTargetDesignatorOff) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.target_designator_off_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.target_designator_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::TargetDesignatorOff& Root::_internal_target_designator_off() const {
  return cmd_case() == kTargetDesignatorOff ? *_impl_.cmd_.target_designator_off_ : reinterpret_cast<::cmd::Lrf::TargetDesignatorOff&>(::cmd::Lrf::_TargetDesignatorOff_default_instance_);
}
inline const ::cmd::Lrf::TargetDesignatorOff& Root::target_designator_off() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.target_designator_off)
  return _internal_target_designator_off();
}
inline ::cmd::Lrf::TargetDesignatorOff* Root::unsafe_arena_release_target_designator_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.target_designator_off)
  if (cmd_case() == kTargetDesignatorOff) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.target_designator_off_;
    _impl_.cmd_.target_designator_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_target_designator_off(::cmd::Lrf::TargetDesignatorOff* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_target_designator_off();
    _impl_.cmd_.target_designator_off_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.target_designator_off)
}
inline ::cmd::Lrf::TargetDesignatorOff* Root::_internal_mutable_target_designator_off() {
  if (cmd_case() != kTargetDesignatorOff) {
    clear_cmd();
    set_has_target_designator_off();
    _impl_.cmd_.target_designator_off_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::TargetDesignatorOff>(GetArena());
  }
  return _impl_.cmd_.target_designator_off_;
}
inline ::cmd::Lrf::TargetDesignatorOff* Root::mutable_target_designator_off() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::TargetDesignatorOff* _msg = _internal_mutable_target_designator_off();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.target_designator_off)
  return _msg;
}

// .cmd.Lrf.TargetDesignatorOnModeA target_designator_on_mode_a = 7;
inline bool Root::has_target_designator_on_mode_a() const {
  return cmd_case() == kTargetDesignatorOnModeA;
}
inline bool Root::_internal_has_target_designator_on_mode_a() const {
  return cmd_case() == kTargetDesignatorOnModeA;
}
inline void Root::set_has_target_designator_on_mode_a() {
  _impl_._oneof_case_[0] = kTargetDesignatorOnModeA;
}
inline void Root::clear_target_designator_on_mode_a() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kTargetDesignatorOnModeA) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.target_designator_on_mode_a_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.target_designator_on_mode_a_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::TargetDesignatorOnModeA* Root::release_target_designator_on_mode_a() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.target_designator_on_mode_a)
  if (cmd_case() == kTargetDesignatorOnModeA) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.target_designator_on_mode_a_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.target_designator_on_mode_a_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::TargetDesignatorOnModeA& Root::_internal_target_designator_on_mode_a() const {
  return cmd_case() == kTargetDesignatorOnModeA ? *_impl_.cmd_.target_designator_on_mode_a_ : reinterpret_cast<::cmd::Lrf::TargetDesignatorOnModeA&>(::cmd::Lrf::_TargetDesignatorOnModeA_default_instance_);
}
inline const ::cmd::Lrf::TargetDesignatorOnModeA& Root::target_designator_on_mode_a() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.target_designator_on_mode_a)
  return _internal_target_designator_on_mode_a();
}
inline ::cmd::Lrf::TargetDesignatorOnModeA* Root::unsafe_arena_release_target_designator_on_mode_a() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.target_designator_on_mode_a)
  if (cmd_case() == kTargetDesignatorOnModeA) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.target_designator_on_mode_a_;
    _impl_.cmd_.target_designator_on_mode_a_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_target_designator_on_mode_a(::cmd::Lrf::TargetDesignatorOnModeA* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_target_designator_on_mode_a();
    _impl_.cmd_.target_designator_on_mode_a_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.target_designator_on_mode_a)
}
inline ::cmd::Lrf::TargetDesignatorOnModeA* Root::_internal_mutable_target_designator_on_mode_a() {
  if (cmd_case() != kTargetDesignatorOnModeA) {
    clear_cmd();
    set_has_target_designator_on_mode_a();
    _impl_.cmd_.target_designator_on_mode_a_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::TargetDesignatorOnModeA>(GetArena());
  }
  return _impl_.cmd_.target_designator_on_mode_a_;
}
inline ::cmd::Lrf::TargetDesignatorOnModeA* Root::mutable_target_designator_on_mode_a() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::TargetDesignatorOnModeA* _msg = _internal_mutable_target_designator_on_mode_a();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.target_designator_on_mode_a)
  return _msg;
}

// .cmd.Lrf.TargetDesignatorOnModeB target_designator_on_mode_b = 8;
inline bool Root::has_target_designator_on_mode_b() const {
  return cmd_case() == kTargetDesignatorOnModeB;
}
inline bool Root::_internal_has_target_designator_on_mode_b() const {
  return cmd_case() == kTargetDesignatorOnModeB;
}
inline void Root::set_has_target_designator_on_mode_b() {
  _impl_._oneof_case_[0] = kTargetDesignatorOnModeB;
}
inline void Root::clear_target_designator_on_mode_b() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kTargetDesignatorOnModeB) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.target_designator_on_mode_b_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.target_designator_on_mode_b_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::TargetDesignatorOnModeB* Root::release_target_designator_on_mode_b() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.target_designator_on_mode_b)
  if (cmd_case() == kTargetDesignatorOnModeB) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.target_designator_on_mode_b_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.target_designator_on_mode_b_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::TargetDesignatorOnModeB& Root::_internal_target_designator_on_mode_b() const {
  return cmd_case() == kTargetDesignatorOnModeB ? *_impl_.cmd_.target_designator_on_mode_b_ : reinterpret_cast<::cmd::Lrf::TargetDesignatorOnModeB&>(::cmd::Lrf::_TargetDesignatorOnModeB_default_instance_);
}
inline const ::cmd::Lrf::TargetDesignatorOnModeB& Root::target_designator_on_mode_b() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.target_designator_on_mode_b)
  return _internal_target_designator_on_mode_b();
}
inline ::cmd::Lrf::TargetDesignatorOnModeB* Root::unsafe_arena_release_target_designator_on_mode_b() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.target_designator_on_mode_b)
  if (cmd_case() == kTargetDesignatorOnModeB) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.target_designator_on_mode_b_;
    _impl_.cmd_.target_designator_on_mode_b_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_target_designator_on_mode_b(::cmd::Lrf::TargetDesignatorOnModeB* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_target_designator_on_mode_b();
    _impl_.cmd_.target_designator_on_mode_b_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.target_designator_on_mode_b)
}
inline ::cmd::Lrf::TargetDesignatorOnModeB* Root::_internal_mutable_target_designator_on_mode_b() {
  if (cmd_case() != kTargetDesignatorOnModeB) {
    clear_cmd();
    set_has_target_designator_on_mode_b();
    _impl_.cmd_.target_designator_on_mode_b_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::TargetDesignatorOnModeB>(GetArena());
  }
  return _impl_.cmd_.target_designator_on_mode_b_;
}
inline ::cmd::Lrf::TargetDesignatorOnModeB* Root::mutable_target_designator_on_mode_b() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::TargetDesignatorOnModeB* _msg = _internal_mutable_target_designator_on_mode_b();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.target_designator_on_mode_b)
  return _msg;
}

// .cmd.Lrf.EnableFogMode enable_fog_mode = 9;
inline bool Root::has_enable_fog_mode() const {
  return cmd_case() == kEnableFogMode;
}
inline bool Root::_internal_has_enable_fog_mode() const {
  return cmd_case() == kEnableFogMode;
}
inline void Root::set_has_enable_fog_mode() {
  _impl_._oneof_case_[0] = kEnableFogMode;
}
inline void Root::clear_enable_fog_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kEnableFogMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.enable_fog_mode_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.enable_fog_mode_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::EnableFogMode* Root::release_enable_fog_mode() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.enable_fog_mode)
  if (cmd_case() == kEnableFogMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.enable_fog_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.enable_fog_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::EnableFogMode& Root::_internal_enable_fog_mode() const {
  return cmd_case() == kEnableFogMode ? *_impl_.cmd_.enable_fog_mode_ : reinterpret_cast<::cmd::Lrf::EnableFogMode&>(::cmd::Lrf::_EnableFogMode_default_instance_);
}
inline const ::cmd::Lrf::EnableFogMode& Root::enable_fog_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.enable_fog_mode)
  return _internal_enable_fog_mode();
}
inline ::cmd::Lrf::EnableFogMode* Root::unsafe_arena_release_enable_fog_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.enable_fog_mode)
  if (cmd_case() == kEnableFogMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.enable_fog_mode_;
    _impl_.cmd_.enable_fog_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_enable_fog_mode(::cmd::Lrf::EnableFogMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_enable_fog_mode();
    _impl_.cmd_.enable_fog_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.enable_fog_mode)
}
inline ::cmd::Lrf::EnableFogMode* Root::_internal_mutable_enable_fog_mode() {
  if (cmd_case() != kEnableFogMode) {
    clear_cmd();
    set_has_enable_fog_mode();
    _impl_.cmd_.enable_fog_mode_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::EnableFogMode>(GetArena());
  }
  return _impl_.cmd_.enable_fog_mode_;
}
inline ::cmd::Lrf::EnableFogMode* Root::mutable_enable_fog_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::EnableFogMode* _msg = _internal_mutable_enable_fog_mode();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.enable_fog_mode)
  return _msg;
}

// .cmd.Lrf.DisableFogMode disable_fog_mode = 10;
inline bool Root::has_disable_fog_mode() const {
  return cmd_case() == kDisableFogMode;
}
inline bool Root::_internal_has_disable_fog_mode() const {
  return cmd_case() == kDisableFogMode;
}
inline void Root::set_has_disable_fog_mode() {
  _impl_._oneof_case_[0] = kDisableFogMode;
}
inline void Root::clear_disable_fog_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kDisableFogMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.disable_fog_mode_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.disable_fog_mode_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::DisableFogMode* Root::release_disable_fog_mode() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.disable_fog_mode)
  if (cmd_case() == kDisableFogMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.disable_fog_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.disable_fog_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::DisableFogMode& Root::_internal_disable_fog_mode() const {
  return cmd_case() == kDisableFogMode ? *_impl_.cmd_.disable_fog_mode_ : reinterpret_cast<::cmd::Lrf::DisableFogMode&>(::cmd::Lrf::_DisableFogMode_default_instance_);
}
inline const ::cmd::Lrf::DisableFogMode& Root::disable_fog_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.disable_fog_mode)
  return _internal_disable_fog_mode();
}
inline ::cmd::Lrf::DisableFogMode* Root::unsafe_arena_release_disable_fog_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.disable_fog_mode)
  if (cmd_case() == kDisableFogMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.disable_fog_mode_;
    _impl_.cmd_.disable_fog_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_disable_fog_mode(::cmd::Lrf::DisableFogMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_disable_fog_mode();
    _impl_.cmd_.disable_fog_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.disable_fog_mode)
}
inline ::cmd::Lrf::DisableFogMode* Root::_internal_mutable_disable_fog_mode() {
  if (cmd_case() != kDisableFogMode) {
    clear_cmd();
    set_has_disable_fog_mode();
    _impl_.cmd_.disable_fog_mode_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::DisableFogMode>(GetArena());
  }
  return _impl_.cmd_.disable_fog_mode_;
}
inline ::cmd::Lrf::DisableFogMode* Root::mutable_disable_fog_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::DisableFogMode* _msg = _internal_mutable_disable_fog_mode();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.disable_fog_mode)
  return _msg;
}

// .cmd.Lrf.SetScanMode set_scan_mode = 11;
inline bool Root::has_set_scan_mode() const {
  return cmd_case() == kSetScanMode;
}
inline bool Root::_internal_has_set_scan_mode() const {
  return cmd_case() == kSetScanMode;
}
inline void Root::set_has_set_scan_mode() {
  _impl_._oneof_case_[0] = kSetScanMode;
}
inline void Root::clear_set_scan_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kSetScanMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_scan_mode_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.set_scan_mode_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::SetScanMode* Root::release_set_scan_mode() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.set_scan_mode)
  if (cmd_case() == kSetScanMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_scan_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_scan_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::SetScanMode& Root::_internal_set_scan_mode() const {
  return cmd_case() == kSetScanMode ? *_impl_.cmd_.set_scan_mode_ : reinterpret_cast<::cmd::Lrf::SetScanMode&>(::cmd::Lrf::_SetScanMode_default_instance_);
}
inline const ::cmd::Lrf::SetScanMode& Root::set_scan_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.set_scan_mode)
  return _internal_set_scan_mode();
}
inline ::cmd::Lrf::SetScanMode* Root::unsafe_arena_release_set_scan_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.set_scan_mode)
  if (cmd_case() == kSetScanMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_scan_mode_;
    _impl_.cmd_.set_scan_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_scan_mode(::cmd::Lrf::SetScanMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_scan_mode();
    _impl_.cmd_.set_scan_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.set_scan_mode)
}
inline ::cmd::Lrf::SetScanMode* Root::_internal_mutable_set_scan_mode() {
  if (cmd_case() != kSetScanMode) {
    clear_cmd();
    set_has_set_scan_mode();
    _impl_.cmd_.set_scan_mode_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::SetScanMode>(GetArena());
  }
  return _impl_.cmd_.set_scan_mode_;
}
inline ::cmd::Lrf::SetScanMode* Root::mutable_set_scan_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::SetScanMode* _msg = _internal_mutable_set_scan_mode();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.set_scan_mode)
  return _msg;
}

// .cmd.Lrf.NewSession new_session = 12;
inline bool Root::has_new_session() const {
  return cmd_case() == kNewSession;
}
inline bool Root::_internal_has_new_session() const {
  return cmd_case() == kNewSession;
}
inline void Root::set_has_new_session() {
  _impl_._oneof_case_[0] = kNewSession;
}
inline void Root::clear_new_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kNewSession) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.new_session_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.new_session_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::NewSession* Root::release_new_session() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.new_session)
  if (cmd_case() == kNewSession) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.new_session_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.new_session_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::NewSession& Root::_internal_new_session() const {
  return cmd_case() == kNewSession ? *_impl_.cmd_.new_session_ : reinterpret_cast<::cmd::Lrf::NewSession&>(::cmd::Lrf::_NewSession_default_instance_);
}
inline const ::cmd::Lrf::NewSession& Root::new_session() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.new_session)
  return _internal_new_session();
}
inline ::cmd::Lrf::NewSession* Root::unsafe_arena_release_new_session() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.new_session)
  if (cmd_case() == kNewSession) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.new_session_;
    _impl_.cmd_.new_session_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_new_session(::cmd::Lrf::NewSession* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_new_session();
    _impl_.cmd_.new_session_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.new_session)
}
inline ::cmd::Lrf::NewSession* Root::_internal_mutable_new_session() {
  if (cmd_case() != kNewSession) {
    clear_cmd();
    set_has_new_session();
    _impl_.cmd_.new_session_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::NewSession>(GetArena());
  }
  return _impl_.cmd_.new_session_;
}
inline ::cmd::Lrf::NewSession* Root::mutable_new_session() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::NewSession* _msg = _internal_mutable_new_session();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.new_session)
  return _msg;
}

// .cmd.Lrf.GetMeteo get_meteo = 13;
inline bool Root::has_get_meteo() const {
  return cmd_case() == kGetMeteo;
}
inline bool Root::_internal_has_get_meteo() const {
  return cmd_case() == kGetMeteo;
}
inline void Root::set_has_get_meteo() {
  _impl_._oneof_case_[0] = kGetMeteo;
}
inline void Root::clear_get_meteo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kGetMeteo) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.get_meteo_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.get_meteo_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::GetMeteo* Root::release_get_meteo() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.get_meteo)
  if (cmd_case() == kGetMeteo) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.get_meteo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.get_meteo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::GetMeteo& Root::_internal_get_meteo() const {
  return cmd_case() == kGetMeteo ? *_impl_.cmd_.get_meteo_ : reinterpret_cast<::cmd::Lrf::GetMeteo&>(::cmd::Lrf::_GetMeteo_default_instance_);
}
inline const ::cmd::Lrf::GetMeteo& Root::get_meteo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.get_meteo)
  return _internal_get_meteo();
}
inline ::cmd::Lrf::GetMeteo* Root::unsafe_arena_release_get_meteo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.get_meteo)
  if (cmd_case() == kGetMeteo) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.get_meteo_;
    _impl_.cmd_.get_meteo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_get_meteo(::cmd::Lrf::GetMeteo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_get_meteo();
    _impl_.cmd_.get_meteo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.get_meteo)
}
inline ::cmd::Lrf::GetMeteo* Root::_internal_mutable_get_meteo() {
  if (cmd_case() != kGetMeteo) {
    clear_cmd();
    set_has_get_meteo();
    _impl_.cmd_.get_meteo_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::GetMeteo>(GetArena());
  }
  return _impl_.cmd_.get_meteo_;
}
inline ::cmd::Lrf::GetMeteo* Root::mutable_get_meteo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::GetMeteo* _msg = _internal_mutable_get_meteo();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.get_meteo)
  return _msg;
}

// .cmd.Lrf.RefineOn refine_on = 14;
inline bool Root::has_refine_on() const {
  return cmd_case() == kRefineOn;
}
inline bool Root::_internal_has_refine_on() const {
  return cmd_case() == kRefineOn;
}
inline void Root::set_has_refine_on() {
  _impl_._oneof_case_[0] = kRefineOn;
}
inline void Root::clear_refine_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kRefineOn) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.refine_on_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.refine_on_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::RefineOn* Root::release_refine_on() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.refine_on)
  if (cmd_case() == kRefineOn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.refine_on_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.refine_on_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::RefineOn& Root::_internal_refine_on() const {
  return cmd_case() == kRefineOn ? *_impl_.cmd_.refine_on_ : reinterpret_cast<::cmd::Lrf::RefineOn&>(::cmd::Lrf::_RefineOn_default_instance_);
}
inline const ::cmd::Lrf::RefineOn& Root::refine_on() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.refine_on)
  return _internal_refine_on();
}
inline ::cmd::Lrf::RefineOn* Root::unsafe_arena_release_refine_on() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.refine_on)
  if (cmd_case() == kRefineOn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.refine_on_;
    _impl_.cmd_.refine_on_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_refine_on(::cmd::Lrf::RefineOn* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_refine_on();
    _impl_.cmd_.refine_on_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.refine_on)
}
inline ::cmd::Lrf::RefineOn* Root::_internal_mutable_refine_on() {
  if (cmd_case() != kRefineOn) {
    clear_cmd();
    set_has_refine_on();
    _impl_.cmd_.refine_on_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::RefineOn>(GetArena());
  }
  return _impl_.cmd_.refine_on_;
}
inline ::cmd::Lrf::RefineOn* Root::mutable_refine_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::RefineOn* _msg = _internal_mutable_refine_on();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.refine_on)
  return _msg;
}

// .cmd.Lrf.RefineOff refine_off = 15;
inline bool Root::has_refine_off() const {
  return cmd_case() == kRefineOff;
}
inline bool Root::_internal_has_refine_off() const {
  return cmd_case() == kRefineOff;
}
inline void Root::set_has_refine_off() {
  _impl_._oneof_case_[0] = kRefineOff;
}
inline void Root::clear_refine_off() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (cmd_case() == kRefineOff) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.refine_off_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.cmd_.refine_off_);
    }
    clear_has_cmd();
  }
}
inline ::cmd::Lrf::RefineOff* Root::release_refine_off() {
  // @@protoc_insertion_point(field_release:cmd.Lrf.Root.refine_off)
  if (cmd_case() == kRefineOff) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.refine_off_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.refine_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::Lrf::RefineOff& Root::_internal_refine_off() const {
  return cmd_case() == kRefineOff ? *_impl_.cmd_.refine_off_ : reinterpret_cast<::cmd::Lrf::RefineOff&>(::cmd::Lrf::_RefineOff_default_instance_);
}
inline const ::cmd::Lrf::RefineOff& Root::refine_off() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.Lrf.Root.refine_off)
  return _internal_refine_off();
}
inline ::cmd::Lrf::RefineOff* Root::unsafe_arena_release_refine_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.Lrf.Root.refine_off)
  if (cmd_case() == kRefineOff) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.refine_off_;
    _impl_.cmd_.refine_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_refine_off(::cmd::Lrf::RefineOff* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_refine_off();
    _impl_.cmd_.refine_off_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.Lrf.Root.refine_off)
}
inline ::cmd::Lrf::RefineOff* Root::_internal_mutable_refine_off() {
  if (cmd_case() != kRefineOff) {
    clear_cmd();
    set_has_refine_off();
    _impl_.cmd_.refine_off_ =
        ::google::protobuf::Message::DefaultConstruct<::cmd::Lrf::RefineOff>(GetArena());
  }
  return _impl_.cmd_.refine_off_;
}
inline ::cmd::Lrf::RefineOff* Root::mutable_refine_off() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::Lrf::RefineOff* _msg = _internal_mutable_refine_off();
  // @@protoc_insertion_point(field_mutable:cmd.Lrf.Root.refine_off)
  return _msg;
}

inline bool Root::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void Root::clear_has_cmd() {
  _impl_._oneof_case_[0] = CMD_NOT_SET;
}
inline Root::CmdCase Root::cmd_case() const {
  return Root::CmdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetMeteo

// -------------------------------------------------------------------

// Start

// -------------------------------------------------------------------

// Stop

// -------------------------------------------------------------------

// Measure

// -------------------------------------------------------------------

// ScanOn

// -------------------------------------------------------------------

// ScanOff

// -------------------------------------------------------------------

// RefineOff

// -------------------------------------------------------------------

// RefineOn

// -------------------------------------------------------------------

// TargetDesignatorOff

// -------------------------------------------------------------------

// TargetDesignatorOnModeA

// -------------------------------------------------------------------

// TargetDesignatorOnModeB

// -------------------------------------------------------------------

// EnableFogMode

// -------------------------------------------------------------------

// DisableFogMode

// -------------------------------------------------------------------

// SetScanMode

// .ser.JonGuiDataLrfScanModes mode = 1;
inline void SetScanMode::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
}
inline ::ser::JonGuiDataLrfScanModes SetScanMode::mode() const {
  // @@protoc_insertion_point(field_get:cmd.Lrf.SetScanMode.mode)
  return _internal_mode();
}
inline void SetScanMode::set_mode(::ser::JonGuiDataLrfScanModes value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:cmd.Lrf.SetScanMode.mode)
}
inline ::ser::JonGuiDataLrfScanModes SetScanMode::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ser::JonGuiDataLrfScanModes>(_impl_.mode_);
}
inline void SetScanMode::_internal_set_mode(::ser::JonGuiDataLrfScanModes value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// NewSession

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Lrf
}  // namespace cmd


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // jon_5fshared_5fcmd_5flrf_2eproto_2epb_2eh
